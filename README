Parser experiment

A quick brain dump for now...

This is a library to help users parse things.

It currently supports simple LR grammars. It will eventually support
LR(1) or LALR(1) grammars.

Unlike tools like bison or yacc, this library will generate parsers at
runtime. It will also allow the user to load a grammar and make
modifications, including adding or removing productions from the
grammar.

Ideally, the syntax could be modified on the fly. This should be
possible due to the fact that the parser states are created on demand,
but I haven't gotten to that feature yet.

Some possible uses I'm imagining:

- user writes a small program to load a C grammar into the parser
  generator, uses parser to syntax check files, doesn't need to load a
  full compiler into memory

- compiler writer uses parser generator library to load the grammar
  for the default language and then makes changes to the grammar based
  on command line switches (ex: removes custom features when -ansi is
  passed in)

- new syntax is added for new types. new syntax for expressions with
  these types, new initializers, etc.

- new syntax is added on the fly... a possible example:

  foo()
  {
    {
      # insert a new expression body, to be used immediately
      # (the semantics of this is to be defined elsewhere)
      syntax-translate { E -> E ** E }

      # use the new expression
      print 2 ** 16
    }

    # this should be a syntax error
    print 2 ** 16
  }

- user wants to parse fragments of a language, so they load the full
  grammar and then point the start state at the appropriate production
